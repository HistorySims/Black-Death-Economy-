<!DOCTYPE html>
<html>
<head>
  <title>Black Death: The Grape Escape</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body{
      font-family:'Courier New', monospace;
      background-color:#2c3e50;
      color:#ecf0f1;
      text-align:center;
      margin:0; padding:0;
      overflow:hidden;
      display:flex; flex-direction:column; height:100vh;
      user-select:none; -webkit-user-select:none;
    }
    #top-bar{
      background:linear-gradient(180deg,#27ae60 0%,#229954 100%);
      padding:5px; display:flex; justify-content:space-around; align-items:center;
      height:55px; border-bottom:4px solid #1e8449; z-index:20;
    }
    .stat-group{ display:flex; flex-direction:column; align-items:center; }
    .stat-label{ font-size:10px; color:#a9dfbf; margin-bottom:4px; font-weight:bold; }
    .stat-val{ font-size:14px; color:#fff; text-shadow:1px 1px 0 #000; font-weight:bold; }

    #game-container{
      flex-grow:1; display:flex; justify-content:center; align-items:center;
      background:#2c3e50; position:relative;
    }
    canvas{ width:100%; height:100%; background-color:#87CEEB; image-rendering:pixelated; }

    #plague-ticker{
      position:absolute; top:10px; width:100%; text-align:center;
      color:#c0392b; font-size:16px; display:none;
      text-shadow:2px 2px 0 #000; pointer-events:none;
      font-weight:bold; background:rgba(0,0,0,0.3); padding:8px 0;
      animation:pulse 2s infinite; z-index:50;
    }
    @keyframes pulse{ 0%,100%{opacity:1;} 50%{opacity:0.7;} }

    #game-over-screen{
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(44,62,80,0.95); display:none;
      flex-direction:column; justify-content:center; align-items:center; z-index:100;
    }
    .result-title{ font-size:24px; color:#f1c40f; margin-bottom:20px; font-weight:bold; }
    #restart-btn{
      padding:15px; background:#e67e22; color:white; border:4px solid #d35400;
      cursor:pointer; margin-top:20px; font-size:16px; font-weight:bold;
    }

    #controls-bar{
      background:linear-gradient(180deg,#2e4053 0%,#1c2833 100%);
      height:130px; display:flex; flex-direction:column; justify-content:center;
      align-items:center; padding:10px 0; border-top:3px solid #34495e;
    }
    .control-panel{
      background:#34495e; border-radius:15px; padding:15px;
      display:flex; align-items:center; gap:20px;
      border:3px solid #4a5f7f;
      box-shadow:0 4px 8px rgba(0,0,0,0.3);
    }
    button{
      width:80px; height:70px; font-size:30px; cursor:pointer;
      background:#e67e22; color:white; border:none;
      border-radius:10px; box-shadow:0 6px #d35400;
      touch-action:manipulation;
    }
    button:active{ box-shadow:0 0 #d35400; transform:translateY(6px); }

    #wage-display-box{ text-align:center; width:140px; }
    .wage-label{ font-size:10px; color:#bdc3c7; display:block; margin-bottom:8px; }
    #wageDisplay{ font-size:30px; color:white; font-weight:bold; }
    .wage-hint{ font-size:10px; color:#7f8c8d; margin-top:5px; }

    #month-bar-container{ position:absolute; top:0; left:0; width:100%; height:6px; background:rgba(44,62,80,0.8); }
    #month-bar{ width:0%; height:100%; background:linear-gradient(90deg,#f1c40f 0%,#f39c12 100%); }
#homeBtn{
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 9999;
  font-family: 'Press Start 2P', cursive;
  font-size: 10px;
  padding: 10px 10px;
  background: rgba(0,0,0,0.35);
  color: #fff;
  border: 3px solid rgba(255,255,255,0.25);
  border-radius: 10px;
  text-decoration: none;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
#homeBtn:active{ transform: translateY(2px); }
  </style>
</head>
<body>
<a id="homeBtn" href="index.html" aria-label="Return to launcher">HOME</a>
  <div id="top-bar">
    <div class="stat-group">
      <span class="stat-label">YEAR</span>
      <span class="stat-val" id="dateDisplay">1345</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">WORKERS</span>
      <span class="stat-val" id="popDisplay">25</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">GOLD</span>
      <span class="stat-val" id="wealthDisplay" style="color:#f1c40f">500</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">AVG WAGE</span>
      <span class="stat-val" id="avgWageDisplay" style="color:#3498db">5g</span>
    </div>
  </div>

  <div id="game-container">
    <div id="plague-ticker">THE BLACK DEATH HAS ARRIVED</div>
    <div id="game-over-screen">
      <div class="result-title" id="final-title">HARVEST ENDED</div>
      <div id="leaderboard"></div>
      <button id="restart-btn" onclick="startGame()">NEXT SEASON</button>
    </div>
    <div id="month-bar-container"><div id="month-bar"></div></div>
    <canvas id="gameCanvas" width="900" height="500"></canvas>
  </div>

  <div id="controls-bar">
    <div class="control-panel">
      <button id="btnMinus">-</button>
      <div id="wage-display-box">
        <span class="wage-label">OFFER WAGE</span>
        <span id="wageDisplay">5g</span>
        <div class="wage-hint" id="wageHint">Match market</div>
      </div>
      <button id="btnPlus">+</button>
    </div>
  </div>

<script>
/*
  HOW TO TUNE (fast testing workflow):
  1) Change ONE variable below (marked with “// adjust (variable) here”).
  2) Reload.
  3) Watch for ~20 seconds.
  4) If it’s too slow/fast, move 10–20% and repeat.

  Tip: If things feel “dead”, increase REGROW_CHANCE slightly.
  Tip: If people feel “antsy”, increase WALK_TO_COL_SPEED a bit.
*/

/* =========================
   BALANCE KNOBS
   ========================= */

// adjust (HARVEST_SPEED) here
// Higher = workers climb/harvest faster (more money flows, more competition).
const HARVEST_SPEED = 0.95;

// adjust (ROT_TIME) here
// Higher = grapes last longer before rotting (less urgency).
const ROT_TIME = 620;

// adjust (REGROW_COOLDOWN) here
// Higher = longer empty time after harvest/rot before regrow can start.
const REGROW_COOLDOWN = 200;

// adjust (REGROW_CHANCE) here
// After cooldown, per-frame chance to regrow. Higher = more grapes.
const REGROW_CHANCE = 0.059;

// adjust (WALK_TO_COL_SPEED) here
// Higher = workers walk faster to a column.
const WALK_TO_COL_SPEED = 1.85;

// adjust (WORKER_WANDER_X / Y) here
// Higher = livelier wandering; too high = jitter.
const WORKER_WANDER_X = 1.00;
const WORKER_WANDER_Y = 0.55;

// adjust (LEAVING_Y_SPEED) here
// Higher = workers drop back to ground faster when leaving.
const LEAVING_Y_SPEED = 1.8;

// adjust (LEAVING_X_MULT) here
// Higher = workers exit screen faster.
const LEAVING_X_MULT = 1.75;

// adjust (PERSPECTIVE_POW) here
// Bigger = MORE spacing at bottom and tighter at top (your white trail effect).
// Try 1.8 (mild), 2.2 (good), 2.8 (strong).
const PERSPECTIVE_POW = 2.2;

// adjust (CONVERGE) here
// Higher = columns converge more strongly as they recede.
const CONVERGE = 0.70;

// adjust (VANISH_LEFT) here
// More negative = converge further LEFT (gives “over a hill” vibe).
const VANISH_LEFT = -90;

// adjust (ARC_LEFT) here
// Higher = stronger leftward bend as they go into distance.
const ARC_LEFT = 34;

// adjust (ARC_POWER) here
// Higher = bend happens later (closer to horizon). Lower = bend starts earlier.
const ARC_POWER = 1.6;


/* =========================
   CORE CONSTANTS
   ========================= */
let canvas, ctx;
const HORIZON_Y = 160;
const GROUND_Y = 400;
const MONTH_FRAMES = 90;
const END_YEAR = 1352;
const PLAYER_IDX = 2;
const GRAPE_VALUE = 80;

const AI = {
  REACT_FRAMES: 18,
  STEP_UP: 1,
  STEP_DOWN: 1,
  MAX_WAGE: GRAPE_VALUE - 2,
  MIN_WAGE: 1
};

const C = {
  sky: '#87CEEB', hills: '#27ae60', ground: '#5d4037',
  vine: '#2ecc71', grape: '#8e44ad',
  rot: '#4e342e',
  playerHighlight: '#f39c12',
  skin: ['#fceabb', '#ffdbac', '#e0ac69'],
  hats: { 'Mercenary':'#c0392b', 'Desperate':'#7f8c8d', 'Stubborn':'#2980b9', 'Steady':'#2ecc71' }
};

let state = {
  year:1346, month:0, monthTimer:0,
  isPlague:false,
  gameActive:false,
  playerWage:5, avgWage:5,
  population:[], vineyards:[],
  floatingTexts:[], hills:[],
  targetPop:25
};

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

/* =========================
   PERSPECTIVE / PROJECTION
   ========================= */

// Correct “white trail” spacing: big gaps near bottom, tight near top.
function vineYFromPct(pct){
  const t = clamp(pct / 100, 0, 1);
  const dist = (GROUND_Y - HORIZON_Y);
  const eased = 1 - Math.pow(1 - t, PERSPECTIVE_POW); // ease-out
  return GROUND_Y - dist * eased;
}

// Columns converge + arc left toward a “vanish point” left of the vineyard.
// baseX = ground post x, vx = vineyard left x, w = vineyard width, t=0..1 distance
function projectX(baseX, vx, w, t){
  const vanishX = (vx + w*0.5) + VANISH_LEFT;           // left of center
  const convergeAmt = clamp(t * CONVERGE, 0, 1);
  const x1 = baseX + (vanishX - baseX) * convergeAmt;   // convergence

  // extra “hill bend”: stronger as you go back
  const bend = ARC_LEFT * Math.pow(t, ARC_POWER);
  return x1 - bend;
}

function marketSnapshot(){
  const wages = state.vineyards.map(v => v.wage).slice().sort((a,b)=>a-b);
  const avg = Math.floor(wages.reduce((s,x)=>s+x,0) / wages.length);
  const max = wages[wages.length-1];
  const second = wages.length>=2 ? wages[wages.length-2] : max;
  return {avg, max, second};
}

function laborSnapshot(){
  let openSlots = 0;
  state.vineyards.forEach(v => openSlots += v.openCols);
  const workers = state.population.length;
  const laborTight = openSlots > 0 ? (workers / openSlots) : 2.0;
  const hiringPressure = state.vineyards.filter(v => v.openCols > 0).length;
  return {openSlots, workers, laborTight, hiringPressure};
}

class FloatingText{
  constructor(x,y,text,color){ this.x=x; this.y=y; this.text=text; this.color=color; this.life=60; }
  draw(){
    ctx.save();
    ctx.globalAlpha = this.life / 60;
    ctx.fillStyle = this.color;
    ctx.font = "bold 14px monospace";
    ctx.fillText(this.text, this.x, this.y);
    ctx.restore();
    this.y -= 0.45; this.life--;
  }
}

class Vineyard{
  constructor(x,index,isPlayer){
    this.x=x; this.w=160; this.index=index; this.isPlayer=isPlayer;
    this.wage = isPlayer ? 5 : Math.floor(Math.random()*3 + 4);
    this.wealth = 500;

    this.aiTimer = 0;
    this.aiTargetWage = this.wage;

    this.cols = [
      {x:30, status:1, rotTimer:0, regrow:0, worker:null, progress:0},
      {x:60, status:1, rotTimer:0, regrow:0, worker:null, progress:0},
      {x:90, status:1, rotTimer:0, regrow:0, worker:null, progress:0},
      {x:120,status:1, rotTimer:0, regrow:0, worker:null, progress:0}
    ];

    if(index===0) this.aiType='Aggressive';
    if(index===1) this.aiType='Steady';
    if(index===3) this.aiType='Panic';
    if(index===4) this.aiType='Cheap';
  }

  get openCols(){ return this.cols.filter(c => c.status===1 && c.worker===null).length; }
  get staffedCols(){ return this.cols.filter(c => c.worker!==null).length; }

  rotPressure(){
    const unworked = this.cols.filter(c => c.status===1 && c.worker===null);
    if(unworked.length===0) return 0;
    let p=0;
    unworked.forEach(c => p += clamp(c.rotTimer / ROT_TIME, 0, 1));
    return p / unworked.length;
  }

  assignWorker(worker){
    const col = this.cols.find(c => c.status===1 && c.worker===null);
    if(col){ col.worker=worker; return col; }
    return null;
  }

  fireWorker(worker){
    const col = this.cols.find(c => c.worker===worker);
    if(col) col.worker=null;
  }

  updateAI(){
    if(this.isPlayer) return;
    this.aiTimer++;
    if(this.aiTimer < AI.REACT_FRAMES) return;
    this.aiTimer = 0;

    const m = marketSnapshot();
    const l = laborSnapshot();

    const empty = this.openCols;
    const staffed = this.staffedCols;
    const rp = this.rotPressure();

    const burnPerHarvest = Math.max(1, this.wage * Math.max(1, staffed));
    const runway = this.wealth / burnPerHarvest;

    const poachThreat = state.vineyards.some(v => v !== this && v.openCols > 0 && v.wage >= this.wage + 1);

    let maxBid = AI.MAX_WAGE;
    if(state.isPlague) maxBid = Math.min(maxBid, GRAPE_VALUE - 5);

    let target = this.wage;

    const isAgg = this.aiType==='Aggressive';
    const isPanic = this.aiType==='Panic';
    const isCheap = this.aiType==='Cheap';

    const cashScared = runway < (state.isPlague ? 1.8 : 1.2);
    const laborShortage = (l.laborTight < 1.05) || state.isPlague;
    const myHiring = empty > 0;

    if(rp > 0.70 && myHiring && !cashScared){
      target = m.max + (isPanic ? 3 : isAgg ? 2 : 1);
    } else if(myHiring){
      if(cashScared){
        target = Math.max(m.avg, m.second);
      } else if(laborShortage){
        if(isAgg) target = m.max + 2;
        else if(isPanic) target = m.max + 3;
        else if(isCheap) target = m.max + (rp > 0.35 ? 1 : 0);
        else target = m.max + 1;
      } else {
        if(isAgg) target = m.max + 1;
        else if(isPanic) target = m.max + 2;
        else if(isCheap) target = Math.max(2, m.avg - 1);
        else target = Math.max(3, m.avg);
      }
    } else {
      if(poachThreat){
        if(isCheap) target = Math.max(m.second, m.max - 1);
        else if(cashScared) target = Math.max(m.avg, m.second);
        else target = isAgg ? m.max : Math.max(m.second, m.max);
      } else {
        if(isAgg) target = Math.max(2, m.avg - 1);
        else if(isPanic) target = Math.max(3, m.avg);
        else if(isCheap) target = Math.max(1, m.avg - 2);
        else target = Math.max(2, m.avg - 1);
      }
    }

    if(isAgg && !cashScared){
      const others = state.vineyards.filter(v => v !== this && !v.isPlayer);
      const poorest = others.reduce((p,v)=> v.wealth < p.wealth ? v : p, others[0]);
      const richEnough = this.wealth > (poorest.wealth + 250);
      const preyIsHiring = poorest && poorest.openCols > 0;
      if(richEnough && preyIsHiring && (laborShortage || state.isPlague)){
        target = Math.max(target, m.max + 2);
      }
    }

    if(isCheap && rp > 0.55 && myHiring && !cashScared){
      target = Math.max(target, m.max + 1);
    }

    target = Math.min(target, maxBid);
    target = clamp(Math.round(target), AI.MIN_WAGE, AI.MAX_WAGE);

    this.aiTargetWage = target;

    if(this.wage < this.aiTargetWage) this.wage += AI.STEP_UP;
    else if(this.wage > this.aiTargetWage) this.wage -= AI.STEP_DOWN;

    this.wage = clamp(this.wage, AI.MIN_WAGE, AI.MAX_WAGE);
  }

  tickGrapes(){
    this.cols.forEach(c => {
      if(c.status === 0){
        if(c.regrow > 0) c.regrow--;
        else if(Math.random() < REGROW_CHANCE){
          c.status = 1; c.rotTimer = 0; c.progress = 0;
        }
      }

      if(c.status === 1 && c.worker === null){
        c.rotTimer++;
        if(c.rotTimer > ROT_TIME){
          c.status = 2;
          if(this.isPlayer) state.floatingTexts.push(new FloatingText(this.x+c.x, GROUND_Y-50, "ROTTED!", '#c0392b'));
        }
      }

      if(c.status === 2){
        c.rotTimer++;
        if(c.rotTimer > ROT_TIME + 140){
          c.status = 0;
          c.regrow = REGROW_COOLDOWN;
        }
      }
    });
  }

  harvestCol(colIdx){
    const col = this.cols[colIdx];
    if(col.status === 1){
      this.wealth += GRAPE_VALUE;
      this.wealth -= this.wage;
      if(this.isPlayer) state.floatingTexts.push(new FloatingText(this.x+col.x, GROUND_Y-50, `+${GRAPE_VALUE-this.wage}g`, '#f1c40f'));
    }
    col.status = 0;
    col.worker = null;
    col.progress = 0;
    col.rotTimer = 0;
    col.regrow = REGROW_COOLDOWN;
    updateUI();
  }

  draw(){
    const vx = this.x;

    ctx.fillStyle = this.isPlayer ? '#795548' : '#5d4037';
    ctx.fillRect(vx, HORIZON_Y, this.w, GROUND_Y - HORIZON_Y);

    if(this.isPlayer){
      ctx.strokeStyle = C.playerHighlight; ctx.lineWidth = 3;
      ctx.strokeRect(vx, HORIZON_Y, this.w, GROUND_Y - HORIZON_Y);
    }

    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.fillRect(vx+10, HORIZON_Y-40, 120, 35);
    ctx.fillStyle = "black"; ctx.font = "bold 12px monospace";
    ctx.fillText(this.wealth + "g", vx+15, HORIZON_Y-25);
    ctx.fillStyle = this.wage >= state.avgWage ? "#27ae60" : "#c0392b";
    ctx.fillText("Pay:" + this.wage, vx+15, HORIZON_Y-10);

    // draw columns
    this.cols.forEach(col => {
      const baseX = vx + col.x;
    // post that follows the SAME projection as the grapes (aligned!)
ctx.strokeStyle = '#3e2723';
ctx.lineWidth = 4;
ctx.beginPath();

// sample points from bottom (t=0) to top (t=1)
const segs = 10;
for(let s=0; s<=segs; s++){
  const t = s / segs;
  const y = vineYFromPct(t * 100);
  const x = projectX(baseX, vx, this.w, t);
  if(s === 0) ctx.moveTo(x, y);
  else ctx.lineTo(x, y);
}
ctx.stroke();
    


      if(col.status > 0){
        const steps = 7;
        for(let i=0; i<steps; i++){
          const t = i/(steps-1);   // 0..1 (0 near viewer)
          const pct = t * 100;

          if(col.worker && pct < col.progress) continue;

          const y = vineYFromPct(pct);
          const x = projectX(baseX, vx, this.w, t);
          const scale = 1.0 - t*0.55;

          ctx.fillStyle = (col.status === 2) ? C.rot : C.vine;
          ctx.beginPath(); ctx.arc(x, y, 12*scale, 0, Math.PI*2); ctx.fill();

          if(col.status === 1){
            ctx.fillStyle = C.grape;
            const sz = 3*scale;
            ctx.beginPath(); ctx.arc(x-sz, y-sz, sz, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x+sz, y-sz, sz, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x, y+sz, sz, 0, Math.PI*2); ctx.fill();
          }
        }
      }
    });
  }
}

class Worker{
  constructor(){ this.reset(true); }
  reset(isSpawn){
    this.x = Math.random() * 900;
    this.y = GROUND_Y + 10 + Math.random() * 40;

    this.speed = 0.55 + Math.random() * 0.85;

    this.isSick = state.isPlague && Math.random() > 0.4;

    const r = Math.random();
    if(r < 0.25) this.trait='Mercenary';
    else if(r < 0.5) this.trait='Desperate';
    else if(r < 0.75) this.trait='Stubborn';
    else this.trait='Steady';

    this.skin = this.isSick ? '#9acd32' : C.skin[Math.floor(Math.random()*3)];
    this.hatColor = C.hats[this.trait];
    this.shirt = '#ecf0f1';

    this.minWage = 1;
    if(this.trait === 'Stubborn') this.minWage = 5;

    this.state='wandering';
    this.targetVineyard=null; this.targetColObj=null; this.targetColIdx=-1;
    this.poachTimer=0; this.patience=50;
    this.animFrame = Math.random()*100;
  }
abandonJob(){
  if(this.targetVineyard){
    // Clear the column slot if it still points to me
    if(this.targetColObj && this.targetColObj.worker === this){
      this.targetColObj.worker = null;
    } else {
      // fallback: search and clear
      this.targetVineyard.fireWorker(this);
    }
  }
  this.targetVineyard = null;
  this.targetColObj = null;
  this.targetColIdx = -1;
}
  think(){
    if(this.isSick && Math.random() < 0.005){
  // If I was mid-harvest / on the way, free the row so others can take over
  this.abandonJob();
  this.state = 'dying';
}
    if(this.state==='dying'){
      this.patience--; if(this.patience < 0) this.state='dead';
      return;
    }

    if(this.state==='working'){
      this.poachTimer++;

      if(this.poachTimer > 20 && Math.random() < 0.1){
        const curWage = this.targetVineyard.wage;
        const better = state.vineyards.find(v => v.wage > curWage && v.openCols > 0);
        if(better){
          this.targetVineyard.fireWorker(this);
          if(this.targetVineyard.isPlayer) state.floatingTexts.push(new FloatingText(this.x, this.y, "I QUIT!", '#e74c3c'));

          const col = better.assignWorker(this);
          if(col){
            this.targetVineyard = better; this.targetColObj = col; this.targetColIdx = better.cols.indexOf(col);
            this.state='walkingToCol'; this.poachTimer=0;
            if(better.isPlayer) state.floatingTexts.push(new FloatingText(this.x, this.y, "HIRED!", '#2ecc71'));
          } else {
            this.state='wandering';
          }
          return;
        }
      }

      if(this.targetColObj){
        this.targetColObj.progress += HARVEST_SPEED;

        const v = this.targetVineyard;
        const baseX = v.x + this.targetColObj.x;
        const t = clamp(this.targetColObj.progress / 100, 0, 1);

        this.x = projectX(baseX, v.x, v.w, t);
        this.y = vineYFromPct(this.targetColObj.progress);

        if(this.targetColObj.progress >= 100){
          this.targetVineyard.harvestCol(this.targetColIdx);
          this.state='leaving';
          this.targetVineyard=null; this.targetColObj=null;
        }
      }
      return;
    }

    if(this.state==='leaving'){
      if(this.y < GROUND_Y+10) this.y += LEAVING_Y_SPEED;
      else{
        this.x += (this.speed * LEAVING_X_MULT);
        if(this.x > 950) this.state='dead';
      }
      return;
    }

    if(this.state==='walkingToCol'){
      const tx = this.targetVineyard.x + this.targetColObj.x;
      const ty = GROUND_Y;
      const dx = tx - this.x, dy = ty - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      const step = WALK_TO_COL_SPEED + this.speed*0.35;

      if(dist < 5){ this.state='working'; this.poachTimer=0; }
      else { this.x += (dx/dist)*step; this.y += (dy/dist)*step; }
      return;
    }

    if(this.state==='wandering'){
      this.patience--;
      if(this.patience < 0){
        this.minWage = Math.max(1, this.minWage - 1);
        this.patience = 50;
      }

      if(Math.random() < 0.2){
        let options = state.vineyards.filter(v => v.openCols > 0 && v.wage >= this.minWage);
        if(options.length > 0){
          options.sort(() => Math.random() - 0.5);
          options.sort((a,b) => b.wage - a.wage);
          const best = options[0];
          const col = best.assignWorker(this);
          if(col){
            this.targetVineyard = best; this.targetColObj = col; this.targetColIdx = best.cols.indexOf(col);
            this.state='walkingToCol';
            if(best.isPlayer) state.floatingTexts.push(new FloatingText(this.x, this.y-20, "HIRED", '#2ecc71'));
          }
        }
      }

      this.x += (Math.random()-0.5) * WORKER_WANDER_X;
      this.y += (Math.random()-0.5) * WORKER_WANDER_Y;

      if(this.y < GROUND_Y) this.y = GROUND_Y;
      if(this.y > 500) this.y = 500;
    }
  }

  draw(){
    if(this.state==='dead') return;

    let px=this.x, py=this.y;
    let s=1.0;
    if(py < GROUND_Y) s = 1.0 - ((GROUND_Y - py)/(GROUND_Y-HORIZON_Y))*0.5;

    if(this.state==='dying'){
      ctx.fillStyle=this.shirt; ctx.fillRect(px, py, 14*s, 6*s);
      ctx.fillStyle='#c0392b'; ctx.font="12px monospace"; ctx.fillText("RIP", px, py-5);
      return;
    }

    this.animFrame++;
    const bob = Math.sin(this.animFrame*0.18)*1.4*s;

    ctx.fillStyle=this.hatColor;
    ctx.fillRect(px-2*s, py-16*s+bob, 14*s, 4*s);
    ctx.fillRect(px+2*s, py-19*s+bob, 6*s, 3*s);

    ctx.fillStyle=this.skin; ctx.fillRect(px+2*s, py-12*s+bob, 6*s, 6*s);
    ctx.fillStyle=this.shirt; ctx.fillRect(px, py-6*s+bob, 10*s, 10*s);
  }
}

function startGame(){ init(); }

function init(){
  document.getElementById('game-over-screen').style.display='none';

  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');

  state.year=1345; state.isPlague=false; state.month=0; state.monthTimer=0;
  state.population=[]; state.vineyards=[]; state.hills=[]; state.floatingTexts=[];
  state.playerWage=5; state.avgWage=5;

  // reset colors in case you restart after plague
  C.sky = '#87CEEB';
  C.hills = '#27ae60';

  for(let i=0; i<900; i+=40) state.hills.push({x:i, y:HORIZON_Y - Math.random()*30});

  const startX = (900 - (5*160))/2 + 10;
  for(let i=0; i<5; i++) state.vineyards.push(new Vineyard(startX + i*160, i, i===PLAYER_IDX));
  for(let i=0; i<30; i++) state.population.push(new Worker());

  state.gameActive=true;
  gameLoop();
  updateUI();
}

function gameLoop(){
  if(!state.gameActive) return;

  state.monthTimer++;
  if(state.monthTimer >= MONTH_FRAMES){ state.monthTimer=0; endMonth(); }

  let totWage=0;
  state.vineyards.forEach(v => { v.updateAI(); v.tickGrapes(); totWage += v.wage; });
  state.avgWage = Math.floor(totWage / 5);

  state.targetPop = state.isPlague ? 10 : 25;
  state.population = state.population.filter(p => p.state !== 'dead');

  const spawnChance = state.isPlague ? 0.01 : 0.05;
  if(state.population.length < state.targetPop && Math.random() < spawnChance){
    state.population.push(new Worker());
  }

  state.population.forEach(p => p.think());
  drawScene();
  requestAnimationFrame(gameLoop);
}

function endMonth(){
  state.month++;
  if(state.month > 11){
    state.month=0; state.year++;
    if(state.year===1348) triggerPlague();
    if(state.year===END_YEAR) showGameOver();
  }
  updateUI();
}

function triggerPlague(){
  state.isPlague=true;
  document.getElementById('plague-ticker').style.display='block';
  C.sky="#5e4b4b"; C.hills="#3e2723";
  state.population.forEach(p => { if(Math.random() < 0.5) p.state='dead'; });
}

function showGameOver(){
  state.gameActive=false;
  document.getElementById('game-over-screen').style.display='flex';
  let html="";
  const rankings = [...state.vineyards].sort((a,b)=>b.wealth - a.wealth);
  rankings.forEach((v, idx) => {
    const label = v.isPlayer ? "YOU" : v.aiType;
    const c = v.isPlayer ? "#f1c40f" : "#bdc3c7";
    html += `<div style='color:${c}'>#${idx+1} ${label}: ${v.wealth}g</div>`;
  });
  document.getElementById('leaderboard').innerHTML = html;
}

function drawScene(){
  ctx.clearRect(0,0,900,500);
  ctx.fillStyle=C.sky; ctx.fillRect(0,0,900,HORIZON_Y);

  ctx.fillStyle=C.hills; ctx.beginPath();
  ctx.moveTo(0,HORIZON_Y); ctx.lineTo(0,HORIZON_Y-50);
  state.hills.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(900, HORIZON_Y); ctx.fill();

  ctx.fillStyle=C.ground; ctx.fillRect(0,HORIZON_Y,900,500);

  state.vineyards.forEach(v => v.draw());
  state.population.sort((a,b)=>a.y - b.y);
  state.population.forEach(p => p.draw());

  state.floatingTexts = state.floatingTexts.filter(ft => ft.life > 0);
  state.floatingTexts.forEach(ft => ft.draw());

  document.getElementById('month-bar').style.width = (state.monthTimer/MONTH_FRAMES)*100 + "%";
}

function adjustWage(amt){
  state.playerWage += amt;
  state.playerWage = clamp(state.playerWage, 1, AI.MAX_WAGE);
  state.vineyards[PLAYER_IDX].wage = state.playerWage;
  updateUI();
}

function updateUI(){
  document.getElementById('wageDisplay').innerText = state.playerWage + "g";
  document.getElementById('wealthDisplay').innerText = state.vineyards[PLAYER_IDX].wealth + "g";
  document.getElementById('avgWageDisplay').innerText = state.avgWage + "g";
  document.getElementById('popDisplay').innerText = `${state.population.length}/${state.targetPop}`;
  document.getElementById('dateDisplay').innerText = state.year;

  const marketMax = Math.max(...state.vineyards.map(v => v.wage));
  let hint="";
  if(state.playerWage < marketMax) hint = "Competitor paying " + marketMax;
  else if(state.playerWage === marketMax) hint = "Tied for Leader";
  else hint = "Market Leader";
  document.getElementById('wageHint').innerText = hint;
}

// Fix mobile double-trigger: pointerdown only.
function setupButtons(){
  const minus = document.getElementById('btnMinus');
  const plus  = document.getElementById('btnPlus');

  const bind = (el, delta) => {
    el.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      el.setPointerCapture?.(e.pointerId);
      adjustWage(delta);
    }, {passive:false});
  };

  bind(minus, -1);
  bind(plus,  1);
}

window.onload = () => {
  setupButtons();
  init();
};
</script>
</body>
</html>
